// Code generated by protoc-gen-go. DO NOT EDIT.
// source: routing/v1alpha2/foreign_service.proto

package istio_routing_v1alpha2

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Different ways of discovering the IP addresses associated with the
// service.
type ForeignService_Discovery int32

const (
	// If set to "none", the proxy will assume that incoming connections
	// have already been resolved (to a specific destination IP
	// address). Such connections are typically routed via the proxy using
	// mechanisms such as IP table REDIRECT/ eBPF. After performing any
	// routing related transformations, the proxy will forward the
	// connection to the IP address to which the connection was bound.
	ForeignService_NONE ForeignService_Discovery = 0
	// If set to "static", the proxy will use specified endpoints (See
	// below) as the backing nodes associated with the foreign service.
	ForeignService_STATIC ForeignService_Discovery = 1
	// If set to "dns", the proxy will attempt to resolve the DNS
	// address during request processing. Use this mode if the set of
	// resolved addresses change dynamically. The "dns" mode is applicable
	// only when the hosts use exact DNS names without any wildcards.
	ForeignService_DNS ForeignService_Discovery = 2
)

var ForeignService_Discovery_name = map[int32]string{
	0: "NONE",
	1: "STATIC",
	2: "DNS",
}
var ForeignService_Discovery_value = map[string]int32{
	"NONE":   0,
	"STATIC": 1,
	"DNS":    2,
}

func (x ForeignService_Discovery) String() string {
	return proto.EnumName(ForeignService_Discovery_name, int32(x))
}
func (ForeignService_Discovery) EnumDescriptor() ([]byte, []int) { return fileDescriptor3, []int{0, 0} }

// Foreign service describes the endpoints, ports and protocols of a
// white-listed set of mesh-external domains and IP blocks that services in
// the mesh are allowed to access.
//
// NOTE: If a foreign service has the same name as a service in the
// service registry, the foreign service's declaration will be given
// precedence.
//
// For example, the following foreign service configuration describes the
// set of services at https://example.com. Eventhough the services behind
// example.com have to be accessed via HTTPS, in order for the application
// to obtain metrics from Istio, a plain text port (HTTP over port 80) is
// declared in addition to a secure port (HTTPS over 443). Connections
// arriving at port 443 on the sidecar will be treated as opaque TCP
// connections and will be forwarded as is to the destination, with limited
// visibility into the application flow. Connections arriving on port 80 on
// the sidecar will be able to take advantage of Istio's advanced routing
// and policy enforcement features. To transparently re-route http
// connections to the destination's https port, a routing rule is needed as
// shown below.
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: ForeignService
//     metadata:
//       name: foreign-svc
//     spec:
//       hosts:
//       - example.com
//       ports:
//       - number: 443
//         name: example-https
//         protocol: https #treated as opaque TCP
//       - number: 80
//         name: http
//         protocol: example-http
//       discovery: none
//
// And the associated route rule to upgrade from http to https
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: RouteRule
//     metadata:
//       name: my-foreign-rule
//     spec:
//       hosts:
//       - example.com
//       http:
//       - match:
//         - port:
//             name: http
//         route:
//         - destination:
//             name: example.com
//             port:
//               name: https
//
// IF the application wishes the sidecar to load balance across several
// hosts backing the foreign service, the discovery mode must be set to one
// of "static" or "dns". The following specification specifies a static set
// of backend nodes for a mongodb cluster behind a set of virtual IPs.
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: ForeignService
//     metadata:
//       name: foreign-svc-mongocluster
//     spec:
//       hosts:
//       - 192.192.192.192/24
//       ports:
//       - number: 27018
//         name: mongodb
//         protocol: mongo
//       discovery: static
//       endpoints:
//       - address: 2.2.2.2
//         ports:
//         - number: 2222
//           name: mongo-host1
//           protocol: mongo
//       - address: 3.3.3.3
//         ports:
//         - number: 3333
//           name: mongo-host2
//           protocol: mongo
//
// The following example demonstrates the use of DNS to dynamically load
// the endpoints for a given foreign service:
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: ForeignService
//     metadata:
//       name: foreign-svc-dns-example
//     spec:
//       hosts:
//       - foo.bar.com
//       ports:
//       - number: 80
//         name: http
//         protocol: http
//       discovery: dns
//
// The application can use HTTP_PROXY settings or IP tables based
// redirection to transparently reroute calls for foo.bar.com to the
// sidecar. The sidecar will resolve the DNS name (foo.bar.com) and load
// balance the requests across one of the endpoints.
//
// When using wildcarded hosts, neither static nor dns discovery mode can
// be used as shown below:
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: ForeignService
//     metadata:
//       name: foreign-svc-dns-example
//     spec:
//       hosts:
//       - *.bar.com
//       ports:
//       - number: 80
//         name: http
//         protocol: http
//       discovery: none
//
type ForeignService struct {
	// REQUIRED. The hosts associated with the external service. Could be a
	// DNS name with wildcard prefix or a CIDR prefix. Note that the hosts
	// field applies to all protocols. Note that DNS names in hosts will be
	// ignored if the application accesses the service over non-HTTP
	// protocols such as mongo/opaque TCP/even HTTPS. In such scenarios, the
	// port on which the external service is being accessed must not be
	// shared by any other service in the mesh. In other words, the sidecar
	// will behave as a simple TCP proxy, forwarding incoming traffic on a
	// specified port to the specified destination endpoint IP/host.
	Hosts []string `protobuf:"bytes,1,rep,name=hosts" json:"hosts,omitempty"`
	// REQUIRED: The Ports associated with the external services.
	Ports []*Port `protobuf:"bytes,2,rep,name=ports" json:"ports,omitempty"`
	// Service discovery mode for the hosts.
	Discovery ForeignService_Discovery `protobuf:"varint,3,opt,name=discovery,enum=istio.routing.v1alpha2.ForeignService_Discovery" json:"discovery,omitempty"`
	// One or more endpoints associated with the service. Endpoints are valid
	// only when the discovery mode is set to "static".
	Endpoints []*ForeignService_Endpoint `protobuf:"bytes,4,rep,name=endpoints" json:"endpoints,omitempty"`
}

func (m *ForeignService) Reset()                    { *m = ForeignService{} }
func (m *ForeignService) String() string            { return proto.CompactTextString(m) }
func (*ForeignService) ProtoMessage()               {}
func (*ForeignService) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{0} }

func (m *ForeignService) GetHosts() []string {
	if m != nil {
		return m.Hosts
	}
	return nil
}

func (m *ForeignService) GetPorts() []*Port {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *ForeignService) GetDiscovery() ForeignService_Discovery {
	if m != nil {
		return m.Discovery
	}
	return ForeignService_NONE
}

func (m *ForeignService) GetEndpoints() []*ForeignService_Endpoint {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

// Endpoint defines a network address (IP:port or hostname:port)
// associated with the foreign service. Needed only for "static"
// discovery mode.
type ForeignService_Endpoint struct {
	// REQUIRED: Address associated with the network endpoint ( IP or fully
	// qualified domain name without wildcards).
	Address string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// The ports on which the endpoint is listening for network
	// connections. Endpoint ports are needed only if they differ from the
	// service ports defined above. Every port associated with the service
	// must have a corresponding port in the Endpoint with same name, with
	// same or different values. For example, the service could refer to
	// port named https with value 443, while the endpoints could refer to
	// "https" with value 8443. The application is expected to access the
	// service using http://<name>:443. The sidecar will automatically
	// reroute the calls to the appropriate endpoint port (8443).
	Ports []*Port `protobuf:"bytes,2,rep,name=ports" json:"ports,omitempty"`
	// One or more labels associated with the endpoint.
	Labels map[string]string `protobuf:"bytes,3,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ForeignService_Endpoint) Reset()                    { *m = ForeignService_Endpoint{} }
func (m *ForeignService_Endpoint) String() string            { return proto.CompactTextString(m) }
func (*ForeignService_Endpoint) ProtoMessage()               {}
func (*ForeignService_Endpoint) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{0, 0} }

func (m *ForeignService_Endpoint) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ForeignService_Endpoint) GetPorts() []*Port {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *ForeignService_Endpoint) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func init() {
	proto.RegisterType((*ForeignService)(nil), "istio.routing.v1alpha2.ForeignService")
	proto.RegisterType((*ForeignService_Endpoint)(nil), "istio.routing.v1alpha2.ForeignService.Endpoint")
	proto.RegisterEnum("istio.routing.v1alpha2.ForeignService_Discovery", ForeignService_Discovery_name, ForeignService_Discovery_value)
}

func init() { proto.RegisterFile("routing/v1alpha2/foreign_service.proto", fileDescriptor3) }

var fileDescriptor3 = []byte{
	// 330 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x92, 0xdd, 0x4a, 0xc3, 0x30,
	0x14, 0xc7, 0x6d, 0xbb, 0xaf, 0x9e, 0xc1, 0x28, 0x41, 0x24, 0x0c, 0x91, 0xb1, 0x0b, 0x29, 0x5e,
	0x64, 0x5a, 0x6f, 0xfc, 0xb8, 0x12, 0x37, 0x41, 0xd0, 0x2a, 0xed, 0xee, 0x25, 0x5b, 0xe3, 0x16,
	0x2c, 0x4d, 0x49, 0xb2, 0x4a, 0xdf, 0xc2, 0xc7, 0xf4, 0x31, 0x64, 0xfd, 0x70, 0x8a, 0x0a, 0xea,
	0x5d, 0xcf, 0xe1, 0xfc, 0x7e, 0xfd, 0x9f, 0x24, 0xb0, 0x2f, 0xc5, 0x4a, 0xf3, 0x64, 0x31, 0xca,
	0x8e, 0x68, 0x9c, 0x2e, 0xa9, 0x37, 0x7a, 0x14, 0x92, 0xf1, 0x45, 0xf2, 0xa0, 0x98, 0xcc, 0xf8,
	0x9c, 0x91, 0x54, 0x0a, 0x2d, 0xd0, 0x0e, 0x57, 0x9a, 0x0b, 0x52, 0x4d, 0x93, 0x7a, 0xba, 0xbf,
	0xf7, 0x85, 0x5f, 0x50, 0xcd, 0x9e, 0x69, 0x5e, 0x72, 0xc3, 0x97, 0x06, 0xf4, 0xae, 0x4a, 0x63,
	0x58, 0x0a, 0xd1, 0x36, 0x34, 0x97, 0x42, 0x69, 0x85, 0x8d, 0x81, 0xe5, 0xda, 0x41, 0x59, 0x20,
	0x0f, 0x9a, 0xa9, 0x90, 0x5a, 0x61, 0x73, 0x60, 0xb9, 0x5d, 0x6f, 0x97, 0x7c, 0xff, 0x43, 0x72,
	0x2f, 0xa4, 0x0e, 0xca, 0x51, 0xe4, 0x83, 0x1d, 0x71, 0x35, 0x17, 0x19, 0x93, 0x39, 0xb6, 0x06,
	0x86, 0xdb, 0xf3, 0x0e, 0x7f, 0xe2, 0x3e, 0x87, 0x20, 0xe3, 0x9a, 0x0b, 0x36, 0x0a, 0x74, 0x0b,
	0x36, 0x4b, 0xa2, 0x54, 0xf0, 0x44, 0x2b, 0xdc, 0x28, 0x72, 0x8c, 0x7e, 0xe9, 0x9b, 0x54, 0x5c,
	0xb0, 0x31, 0xf4, 0x5f, 0x0d, 0xe8, 0xd4, 0x7d, 0x84, 0xa1, 0x4d, 0xa3, 0x48, 0x32, 0xb5, 0xde,
	0xdb, 0x70, 0xed, 0xa0, 0x2e, 0xff, 0xb5, 0x79, 0x08, 0xad, 0x98, 0xce, 0x58, 0xac, 0xb0, 0x55,
	0x40, 0xe7, 0x7f, 0x8c, 0x49, 0x6e, 0x0a, 0x7a, 0x92, 0x68, 0x99, 0x07, 0x95, 0xaa, 0x7f, 0x0a,
	0xdd, 0x0f, 0x6d, 0xe4, 0x80, 0xf5, 0xc4, 0xf2, 0x2a, 0xed, 0xfa, 0x73, 0x7d, 0x73, 0x19, 0x8d,
	0x57, 0x0c, 0x9b, 0x45, 0xaf, 0x2c, 0xce, 0xcc, 0x13, 0x63, 0x78, 0x00, 0xf6, 0xfb, 0x89, 0xa2,
	0x0e, 0x34, 0xfc, 0x3b, 0x7f, 0xe2, 0x6c, 0x21, 0x80, 0x56, 0x38, 0xbd, 0x98, 0x5e, 0x5f, 0x3a,
	0x06, 0x6a, 0x83, 0x35, 0xf6, 0x43, 0xc7, 0x9c, 0xb5, 0x8a, 0x97, 0x71, 0xfc, 0x16, 0x00, 0x00,
	0xff, 0xff, 0xad, 0x8d, 0x8d, 0x6f, 0x7b, 0x02, 0x00, 0x00,
}
