// Code generated by protoc-gen-go. DO NOT EDIT.
// source: routing/v1alpha2/foreign_services.proto

package istio_routing_v1alpha2

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Different ways of discovering the IP addresses associated with the
// service.
type Service_Discovery int32

const (
	// If set to "none", the proxy will assume that incoming connections
	// have already been resolved (to a specific destination IP
	// address). Such connections are typically routed via the proxy using
	// mechanisms such as IP table REDIRECT/ eBPF. After performing any
	// routing related transformations, the proxy will forward the
	// connection to the IP address to which the connection was bound.
	Service_NONE Service_Discovery = 0
	// If set to "static", the proxy will use specified endpoints (See
	// below) as the backing nodes associated with the foreign service.
	Service_STATIC Service_Discovery = 1
	// If set to "dns", the proxy will attempt to resolve the DNS
	// address during request processing. Use this mode if the set of
	// resolved addresses change dynamically. The "dns" mode is applicable
	// only when the hosts use exact DNS names without any wildcards.
	Service_DNS Service_Discovery = 2
)

var Service_Discovery_name = map[int32]string{
	0: "NONE",
	1: "STATIC",
	2: "DNS",
}
var Service_Discovery_value = map[string]int32{
	"NONE":   0,
	"STATIC": 1,
	"DNS":    2,
}

func (x Service_Discovery) String() string {
	return proto.EnumName(Service_Discovery_name, int32(x))
}
func (Service_Discovery) EnumDescriptor() ([]byte, []int) { return fileDescriptor3, []int{1, 0} }

// Service registry entries describe describe the endpoints, ports and
// protocols of a white-listed set of mesh-external domains and IP blocks
// that services in the mesh are allowed to access.
//
// NOTE 1: If a foreign service has the same name as a service in the
// service registry, the foreign service's declaration will be given
// precedence.
//
// NOTE 2: There can be ONLY ONE ForeignServices configuration for the
// entire mesh.
//
// For example, the following foreign services configuration describes the
// set of services at https://example.com. Eventhough the services behind
// example.com have to be accessed via HTTPS, in order for the application to
// obtain metrics from Istio, a plain text port (HTTP over port 80) is
// declared in addition to a secure port (HTTPS over 443). Connections
// arriving at port 443 on the sidecar will be treated as opaque TCP
// connections and will be forwarded as is to the destination, with limited
// visibility into the application flow. Connections arriving on port 80 on
// the sidecar will be able to take advantage of Istio's advanced routing
// and policy enforcement features. The associated routing rule ensures
// that outbound connections from the sidecar to the destination service
// happen over HTTPS.
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: ForeignServices
//     metadata:
//       name: foreign-svc
//     spec:
//       services:
//       - hosts:
//         - example.com
//         ports:
//         - number: 443
//           name: https
//           protocol: HTTPS #treated as opaque TCP
//         - number: 80
//           name: http
//           protocol: HTTP
//         discovery: none
//
// And the associated route rule
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: RouteRule
//     metadata:
//       name: my-foreign-rule
//     spec:
//       hosts:
//       - example.com
//       http:
//       - match:
//         - port:
//             name: http
//         route:
//         - destination:
//             name: example.com
//             port:
//               name: https
//
// Route rules can also be applied to services described in the
// ForeignServices resource. The following sample route rule rewrites
// /foocatalog to /barcatalog before forwarding the call to the intended
// destination.
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: RouteRule
//     metadata:
//       name: foo-rule
//     spec:
//       hosts:
//       - example.com
//       http:
//       - match:
//         - uri:
//             prefix: /foocatalog
//         rewrite:
//           uri: /barcatalog
//
type ForeignServices struct {
	// REQUIRED: A list of server specifications.
	Services []*Service `protobuf:"bytes,1,rep,name=services" json:"services,omitempty"`
}

func (m *ForeignServices) Reset()                    { *m = ForeignServices{} }
func (m *ForeignServices) String() string            { return proto.CompactTextString(m) }
func (*ForeignServices) ProtoMessage()               {}
func (*ForeignServices) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{0} }

func (m *ForeignServices) GetServices() []*Service {
	if m != nil {
		return m.Services
	}
	return nil
}

// Service describes the endpoints, ports and protocols of the external
// service to be made accessible from within the mesh. For example,
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: ForeignServices
//     metadata:
//       name: foreign-svc
//     spec:
//       services:
//       - hosts:
//         - *.foo.com
//         ports:
//         - number: 80
//           protocol: HTTP2
//           name: http2
//         discovery: none
//       - hosts:
//         - 192.192.33.33/16
//         ports:
//         - number: 27018
//           protocol: MONGO
//           name: mongo
//         discovery: none
//
type Service struct {
	// REQUIRED. The hosts associated with the external service. Could be a
	// DNS name with wildcard prefix or a CIDR prefix. Note that the hosts
	// field applies to all protocols.
	Hosts []string `protobuf:"bytes,1,rep,name=hosts" json:"hosts,omitempty"`
	// REQUIRED: The Ports associated with the external services.
	Ports []*Port `protobuf:"bytes,2,rep,name=ports" json:"ports,omitempty"`
	// Service discovery mode for the hosts.
	Discovery Service_Discovery `protobuf:"varint,3,opt,name=discovery,enum=istio.routing.v1alpha2.Service_Discovery" json:"discovery,omitempty"`
	// One or more endpoints associated with the service. Endpoints are valid
	// only when the discovery mode is set to "static".
	Endpoints []*Service_Endpoint `protobuf:"bytes,4,rep,name=endpoints" json:"endpoints,omitempty"`
}

func (m *Service) Reset()                    { *m = Service{} }
func (m *Service) String() string            { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()               {}
func (*Service) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{1} }

func (m *Service) GetHosts() []string {
	if m != nil {
		return m.Hosts
	}
	return nil
}

func (m *Service) GetPorts() []*Port {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *Service) GetDiscovery() Service_Discovery {
	if m != nil {
		return m.Discovery
	}
	return Service_NONE
}

func (m *Service) GetEndpoints() []*Service_Endpoint {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

// Endpoint defines a network address (IP:port or hostname:port)
// associated with the foreign service. Needed only for "static"
// discovery mode.
type Service_Endpoint struct {
	// REQUIRED: Address associated with the network endpoint ( IP or fully
	// qualified domain name without wildcards).
	Address string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// The ports on which the endpoint is listening for network
	// connections. Endpoint ports are needed only if they differ from the
	// service ports defined above. Endpoint ports must have the same name
	// as the associated service port, but can have different values. For
	// example, the service could refer to port named https with value 443,
	// while the endpoints could refer to "https" with value 8443. The
	// application is expected to access the service using
	// http://<name>:443. The sidecar will automatically reroute the calls
	// to the appropriate endpoint port.
	Ports []*Port `protobuf:"bytes,2,rep,name=ports" json:"ports,omitempty"`
	// One or more labels associated with the endpoint.
	Labels map[string]string `protobuf:"bytes,3,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Service_Endpoint) Reset()                    { *m = Service_Endpoint{} }
func (m *Service_Endpoint) String() string            { return proto.CompactTextString(m) }
func (*Service_Endpoint) ProtoMessage()               {}
func (*Service_Endpoint) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{1, 0} }

func (m *Service_Endpoint) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Service_Endpoint) GetPorts() []*Port {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *Service_Endpoint) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func init() {
	proto.RegisterType((*ForeignServices)(nil), "istio.routing.v1alpha2.ForeignServices")
	proto.RegisterType((*Service)(nil), "istio.routing.v1alpha2.Service")
	proto.RegisterType((*Service_Endpoint)(nil), "istio.routing.v1alpha2.Service.Endpoint")
	proto.RegisterEnum("istio.routing.v1alpha2.Service_Discovery", Service_Discovery_name, Service_Discovery_value)
}

func init() { proto.RegisterFile("routing/v1alpha2/foreign_services.proto", fileDescriptor3) }

var fileDescriptor3 = []byte{
	// 349 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x92, 0x4d, 0x4b, 0xeb, 0x40,
	0x14, 0x86, 0x6f, 0x92, 0x7e, 0xe5, 0x14, 0xee, 0x0d, 0xc3, 0xe5, 0x12, 0xca, 0x45, 0x4b, 0x37,
	0x46, 0x17, 0x29, 0x46, 0x17, 0x7e, 0xac, 0xc4, 0xb6, 0x22, 0x94, 0x28, 0xd3, 0xee, 0x65, 0xda,
	0x8c, 0xed, 0x60, 0xc8, 0x84, 0x99, 0x69, 0x24, 0x3f, 0xd7, 0xff, 0xe0, 0x0f, 0x90, 0x26, 0x93,
	0x56, 0x50, 0xa9, 0xb8, 0xcb, 0x79, 0x39, 0xcf, 0xc3, 0x7b, 0x92, 0xc0, 0x81, 0xe0, 0x2b, 0xc5,
	0x92, 0x45, 0x3f, 0x3b, 0x26, 0x71, 0xba, 0x24, 0x41, 0xff, 0x91, 0x0b, 0xca, 0x16, 0xc9, 0x83,
	0xa4, 0x22, 0x63, 0x73, 0x2a, 0xfd, 0x54, 0x70, 0xc5, 0xd1, 0x3f, 0x26, 0x15, 0xe3, 0xbe, 0x5e,
	0xf7, 0xab, 0xf5, 0xce, 0xde, 0x07, 0xc1, 0x82, 0x28, 0xfa, 0x4c, 0xf2, 0x92, 0xeb, 0x85, 0xf0,
	0x67, 0x54, 0x1a, 0x27, 0x5a, 0x88, 0x2e, 0xa1, 0x55, 0xc9, 0x5d, 0xa3, 0x6b, 0x79, 0xed, 0x60,
	0xdf, 0xff, 0xdc, 0xee, 0x6b, 0x06, 0x6f, 0x80, 0xde, 0xab, 0x05, 0x4d, 0x9d, 0xa2, 0xbf, 0x50,
	0x5f, 0x72, 0xa9, 0x4a, 0x8b, 0x8d, 0xcb, 0x01, 0x05, 0x50, 0x4f, 0xb9, 0x50, 0xd2, 0x35, 0x0b,
	0xf7, 0xff, 0xaf, 0xdc, 0xf7, 0x5c, 0x28, 0x5c, 0xae, 0xa2, 0x1b, 0xb0, 0x23, 0x26, 0xe7, 0x3c,
	0xa3, 0x22, 0x77, 0xad, 0xae, 0xe1, 0xfd, 0x0e, 0x0e, 0x77, 0x74, 0xf2, 0x07, 0x15, 0x80, 0xb7,
	0x2c, 0x1a, 0x81, 0x4d, 0x93, 0x28, 0xe5, 0x2c, 0x51, 0xd2, 0xad, 0x15, 0x05, 0xbc, 0x5d, 0xa2,
	0xa1, 0x06, 0xf0, 0x16, 0xed, 0xbc, 0x18, 0xd0, 0xaa, 0x72, 0xe4, 0x42, 0x93, 0x44, 0x91, 0xa0,
	0x72, 0x7d, 0xa9, 0xe1, 0xd9, 0xb8, 0x1a, 0x7f, 0x74, 0xeb, 0x18, 0x1a, 0x31, 0x99, 0xd1, 0x58,
	0xba, 0x56, 0x01, 0x9d, 0x7e, 0xb7, 0x9f, 0x3f, 0x2e, 0xb0, 0x61, 0xa2, 0x44, 0x8e, 0xb5, 0xa3,
	0x73, 0x0e, 0xed, 0x77, 0x31, 0x72, 0xc0, 0x7a, 0xa2, 0xb9, 0xae, 0xb9, 0x7e, 0x5c, 0x7f, 0xa4,
	0x8c, 0xc4, 0x2b, 0xea, 0x9a, 0x45, 0x56, 0x0e, 0x17, 0xe6, 0x99, 0xd1, 0x3b, 0x02, 0x7b, 0xf3,
	0x0e, 0x51, 0x0b, 0x6a, 0xe1, 0x5d, 0x38, 0x74, 0x7e, 0x21, 0x80, 0xc6, 0x64, 0x7a, 0x35, 0xbd,
	0xbd, 0x76, 0x0c, 0xd4, 0x04, 0x6b, 0x10, 0x4e, 0x1c, 0x73, 0xd6, 0x28, 0xfe, 0xa6, 0x93, 0xb7,
	0x00, 0x00, 0x00, 0xff, 0xff, 0xc3, 0x2a, 0xec, 0x72, 0xb0, 0x02, 0x00, 0x00,
}
