// Code generated by protoc-gen-go. DO NOT EDIT.
// source: routing/v1alpha2/foreign_services.proto

package istio_routing_v1alpha2

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Different ways of resolving the IP address of the service.
type Service_Resolution int32

const (
	// If set to "local", the proxy will assume that incoming connections
	// have already been resolved (to a specific destination IP
	// address). Such connections are typically routed via the proxy using
	// mechanisms such as IP table REDIRECT/ eBPF. After performing any
	// routing related transformations, the proxy will forward the
	// connection to the IP address to which the connection was bound.
	Service_LOCAL Service_Resolution = 0
	// If set to "static", Istio will attempt to resolve the DNS name into
	// a set of IP addresses, and use the resulting set as the load
	// balancing pool for the service. Note that static mode is applicable
	// only when the hosts use exact DNS names without any wildcards.
	Service_STATIC Service_Resolution = 1
	// If set to "dynamic", the proxy will attempt to resolve the DNS
	// address during request processing. Use this mode if the set of
	// resolved addresses change dynamically. Dynamic mode is applicable
	// only when the hosts use exact DNS names without any wildcards.
	Service_DYNAMIC Service_Resolution = 2
)

var Service_Resolution_name = map[int32]string{
	0: "LOCAL",
	1: "STATIC",
	2: "DYNAMIC",
}
var Service_Resolution_value = map[string]int32{
	"LOCAL":   0,
	"STATIC":  1,
	"DYNAMIC": 2,
}

func (x Service_Resolution) String() string {
	return proto.EnumName(Service_Resolution_name, int32(x))
}
func (Service_Resolution) EnumDescriptor() ([]byte, []int) { return fileDescriptor3, []int{1, 0} }

// Foreign services describe the properties of services outside Istio. It
// contains a white-listed set of mesh-external domains and IP blocks that
// services in the mesh are allowed to access.
//
// If a foreign service expects HTTPS then that service can be accessed by
// application code using HTTP and the sidecar will originate TLS on its
// behalf. If the application has to originate TLS, the service should be
// declared as a TCP service and the sidecar will simply forward it as
// opaque TCP traffic.
//
// NOTE 1: If a foreign service has the same name as a service in the
// service registry, the foreign service's declaration will be given
// precedence.
//
// NOTE 2: There can be ONLY ONE ForeignServices configuration for the
// entire mesh.
//
// For example, the following foreign services configuration describes the
// set of services at https://*.foo.com:443 and http://example.bar.com:80.  Calls
// to *.foo.com are treated as opaque TCP calls as the application
// originates TLS. Calls to example.bar.com are treated as HTTP, as the
// application makes plaintext HTTP calls and expects the sidecar to
// originate TLS. The associated destination rule configures the sidecar to
// originate TLS when making the outbound call to example.bar.com.
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: ForeignServices
//     metadata:
//       name: foreign-svc
//     spec:
//       services:
//       - hosts:
//         - *.foo.com
//         ports:
//         - number: 443
//           name: https
//           protocol: HTTPS #application originates TLS
//         resolution: local
//       - hosts:
//         - example.bar.com
//         ports:
//         - number: 80 # app is expected to use http://example.bar.com
//           name: http
//           protocol: HTTP
//         resolution: dynamic
//
// And the associated DestinationRule
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: DestinationRule
//     metadata:
//       name: my-destination-rule
//     spec:
//       name: example.bar.com
//       tls:
//         mode: simple # the sidecar will originate HTTPS to example.com
//
// Route rules can also be applied to services described in the
// ForeignServices resource. The following sample route rule rewrites
// /foocatalog to /barcatalog before forwarding the call to the intended
// destination.
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: RouteRule
//     metadata:
//       name: foo-rule
//     spec:
//       hosts:
//       - *.foo.com
//       http:
//       - match:
//         - uri:
//             prefix: /foocatalog
//         rewrite:
//           uri: /barcatalog
//
type ForeignServices struct {
	// REQUIRED: A list of server specifications.
	Services []*Service `protobuf:"bytes,1,rep,name=services" json:"services,omitempty"`
}

func (m *ForeignServices) Reset()                    { *m = ForeignServices{} }
func (m *ForeignServices) String() string            { return proto.CompactTextString(m) }
func (*ForeignServices) ProtoMessage()               {}
func (*ForeignServices) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{0} }

func (m *ForeignServices) GetServices() []*Service {
	if m != nil {
		return m.Services
	}
	return nil
}

// Service describes the properties of the external service that should be
// made accessible from within the mesh. For example,
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: ForeignServices
//     metadata:
//       name: foreign-svc
//     spec:
//       services:
//       - hosts:
//         - *.foo.com
//         ports:
//         - number: 80
//           protocol: HTTP2
//           name: http2
//         resolution: local
//       - hosts:
//         - 192.192.33.33/16
//         ports:
//         - number: 27018
//           protocol: MONGO
//           name: mongo
//         resolution: local
//
type Service struct {
	// REQUIRED. The destination address of the external service. Could be a
	// DNS name with wildcard prefix or a CIDR prefix. Note that the hosts
	// field applies to all protocols.
	Hosts []string `protobuf:"bytes,1,rep,name=hosts" json:"hosts,omitempty"`
	// REQUIRED: The Ports associated with the external services.
	Ports []*Service_Port `protobuf:"bytes,2,rep,name=ports" json:"ports,omitempty"`
	// DNS resolution mode for the hosts.
	Resolution Service_Resolution `protobuf:"varint,3,opt,name=resolution,enum=istio.routing.v1alpha2.Service_Resolution" json:"resolution,omitempty"`
}

func (m *Service) Reset()                    { *m = Service{} }
func (m *Service) String() string            { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()               {}
func (*Service) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{1} }

func (m *Service) GetHosts() []string {
	if m != nil {
		return m.Hosts
	}
	return nil
}

func (m *Service) GetPorts() []*Service_Port {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *Service) GetResolution() Service_Resolution {
	if m != nil {
		return m.Resolution
	}
	return Service_LOCAL
}

// Port describes the properties of a specific port of a service.
type Service_Port struct {
	// REQUIRED: A valid non-negative integer port number.
	Number uint32 `protobuf:"varint,1,opt,name=number" json:"number,omitempty"`
	// The protocol exposed on the port.
	// MUST BE one of HTTP|HTTPS|GRPC|HTTP2|MONGO|TCP.
	Protocol string `protobuf:"bytes,2,opt,name=protocol" json:"protocol,omitempty"`
	// Label assigned to the port.
	Name string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
}

func (m *Service_Port) Reset()                    { *m = Service_Port{} }
func (m *Service_Port) String() string            { return proto.CompactTextString(m) }
func (*Service_Port) ProtoMessage()               {}
func (*Service_Port) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{1, 0} }

func (m *Service_Port) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *Service_Port) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *Service_Port) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func init() {
	proto.RegisterType((*ForeignServices)(nil), "istio.routing.v1alpha2.ForeignServices")
	proto.RegisterType((*Service)(nil), "istio.routing.v1alpha2.Service")
	proto.RegisterType((*Service_Port)(nil), "istio.routing.v1alpha2.Service.Port")
	proto.RegisterEnum("istio.routing.v1alpha2.Service_Resolution", Service_Resolution_name, Service_Resolution_value)
}

func init() { proto.RegisterFile("routing/v1alpha2/foreign_services.proto", fileDescriptor3) }

var fileDescriptor3 = []byte{
	// 284 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x90, 0x4f, 0x4b, 0xf3, 0x40,
	0x10, 0xc6, 0xdf, 0x4d, 0xff, 0x66, 0xca, 0xab, 0x61, 0x90, 0x12, 0x7a, 0x31, 0x04, 0xc1, 0xe0,
	0x61, 0xab, 0xf1, 0xa6, 0xa7, 0x10, 0x11, 0x2a, 0x35, 0xca, 0xb6, 0x17, 0x4f, 0x92, 0x96, 0xb5,
	0x5d, 0x48, 0xb3, 0x61, 0x77, 0xd3, 0xef, 0xe4, 0xb7, 0x14, 0x93, 0x34, 0x7a, 0x10, 0x7a, 0xdb,
	0x67, 0x79, 0x7e, 0xbf, 0x19, 0x06, 0x2e, 0x95, 0x2c, 0x8d, 0xc8, 0x37, 0xd3, 0xfd, 0x4d, 0x9a,
	0x15, 0xdb, 0x34, 0x9c, 0x7e, 0x48, 0xc5, 0xc5, 0x26, 0x7f, 0xd7, 0x5c, 0xed, 0xc5, 0x9a, 0x6b,
	0x5a, 0x28, 0x69, 0x24, 0x8e, 0x85, 0x36, 0x42, 0xd2, 0xa6, 0x4e, 0x0f, 0x75, 0x3f, 0x81, 0xd3,
	0xc7, 0x9a, 0x58, 0x34, 0x00, 0xde, 0xc3, 0xf0, 0x00, 0xbb, 0xc4, 0xeb, 0x04, 0xa3, 0xf0, 0x9c,
	0xfe, 0x4d, 0xd3, 0x86, 0x61, 0x2d, 0xe0, 0x7f, 0x5a, 0x30, 0x68, 0x7e, 0xf1, 0x0c, 0x7a, 0x5b,
	0xa9, 0x4d, 0x6d, 0xb1, 0x59, 0x1d, 0xf0, 0x0e, 0x7a, 0x85, 0x54, 0x46, 0xbb, 0x56, 0xe5, 0xbe,
	0x38, 0xe2, 0xa6, 0xaf, 0x52, 0x19, 0x56, 0x23, 0xf8, 0x04, 0xa0, 0xb8, 0x96, 0x59, 0x69, 0x84,
	0xcc, 0xdd, 0x8e, 0x47, 0x82, 0x93, 0xf0, 0xea, 0x98, 0x80, 0xb5, 0x04, 0xfb, 0x45, 0x4f, 0x12,
	0xe8, 0x7e, 0xab, 0x71, 0x0c, 0xfd, 0xbc, 0xdc, 0xad, 0xb8, 0x72, 0x89, 0x47, 0x82, 0xff, 0xac,
	0x49, 0x38, 0x81, 0x61, 0x75, 0xba, 0xb5, 0xcc, 0x5c, 0xcb, 0x23, 0x81, 0xcd, 0xda, 0x8c, 0x08,
	0xdd, 0x3c, 0xdd, 0xf1, 0x6a, 0x03, 0x9b, 0x55, 0x6f, 0xff, 0x1a, 0xe0, 0x67, 0x12, 0xda, 0xd0,
	0x9b, 0xbf, 0xc4, 0xd1, 0xdc, 0xf9, 0x87, 0x00, 0xfd, 0xc5, 0x32, 0x5a, 0xce, 0x62, 0x87, 0xe0,
	0x08, 0x06, 0x0f, 0x6f, 0x49, 0xf4, 0x3c, 0x8b, 0x1d, 0x6b, 0xd5, 0xaf, 0x7c, 0xb7, 0x5f, 0x01,
	0x00, 0x00, 0xff, 0xff, 0x88, 0x60, 0x11, 0x55, 0xc5, 0x01, 0x00, 0x00,
}
